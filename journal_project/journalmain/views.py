from django.shortcuts import render, get_object_or_404
from django.http import HttpResponse, HttpResponseRedirect
from .models import JournalEntry, Blurb, Report
import json
from .forms import JournalForm
# Create your views here.


# Simple helper function:
mood_colors = {
    "happy": "badge-primary",
    "sad": "badge-secondary",
    "angry": "badge-danger",
    "afraid": "badge-warning",
    "excited": "badge-success",
    "calm": "badge-info",
    "worried": "badge-light",
    "in love": "badge-danger",
    "surprised": "badge-warning",
    "proud": "badge-success",
    "ashamed": "badge-secondary",
    "frustrated": "badge-danger",
    "guilty": "badge-danger",
    "curious": "badge-info",
    "nostalgic": "badge-light",
    "hopeful": "badge-primary",
    "disappointed": "badge-secondary",
    "embarrassed": "badge-secondary",
    "envious": "badge-danger",
    "grateful": "badge-success",
    "longing": "badge-info",
    "relieved": "badge-primary",
    "optimistic": "badge-primary",
    "pessimistic": "badge-dark"
}

def mood_list_creation(entry: JournalEntry):
    return_list = []
    if(entry.mood is None):
        return ['<span class="badge badge-pill badge-light">Journal is yet to be processed by AI</span>']
    else:
        # We expect that entry.mood is a valid python array
        try:
            # Hacky way of doing this, but, this is the best I can think of
            print(json.loads(entry.mood.replace("'", '"'))) # AI will generate the list with either ' or ", this fixes it
            moodl = json.loads(entry.mood.replace("'", '"'))
            for element in moodl:
                print(element)
                if mood_colors.get(element) is not None:
                    return_list.append(f'<span class="badge badge-pill {mood_colors.get(element)}">{element}</span>')
        except:
           return ['<span class="badge badge-pill badge-danger">Mood list generated by AI is invalid</span>']
    print(return_list)
    return return_list

def journals(request):
    journal_entries = JournalEntry.objects.filter(user=request.user)
    return render(request, 'journalindex.html', {'journal_entries': journal_entries}) #HttpResponse("Hello world!")

def journal_detail(request, id):
    entry = get_object_or_404(JournalEntry, id=id, user=request.user)
    mood = mood_list_creation(entry)
    return render(request, 'journal_detail.html', {'entry': entry, 'moods' : mood})

def journal_create(request):
    if request.method == "POST":
        # create a form instance and populate it with data from the request:
        form = JournalForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            # process the data in form.cleaned_data as required
            print(form.cleaned_data)
            new = JournalEntry()
            print(form.errors)
            new.content = form.cleaned_data['content']
            if len(form.cleaned_data['reflections']) > 5:
                new.reflections = form.cleaned_data['reflections']
            if len(form.cleaned_data['gratitude']) > 5:
                new.gratitude = form.cleaned_data['gratitude']
            new.user =  request.user # This WILL error when not logged in, but, that's fine
            new.save()
            # Let's mark the blurbs as spent now
            # Note this has a known issue - if the blurb was sent after the user started journaling
            # but before it was submitted, it would be marked as spent. This is not a big deal.
            for blurb in Blurb.objects.filter(user=request.user, journalEntry=None):
                blurb.journalEntry = new
                blurb.save()
            # redirect to a new URL:
            return HttpResponseRedirect("/journals/")    
        return render(request, 'journal_submit.html', {'form':form})
    else:
        form = JournalForm()
        blurbs = list(Blurb.objects.filter(user=request.user, journalEntry=None))
        return render(request, 'journal_submit.html', {'form':form, 'blurbs' : blurbs})

def report_detail(request, id):
    report_entry = get_object_or_404(Report, id=id, user=request.user)
    return render(request, 'report_detail.html', {'report_entry' : report_entry})
