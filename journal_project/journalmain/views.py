from django.shortcuts import render, get_object_or_404
from django.http import HttpResponse, HttpResponseRedirect
from .models import JournalEntry, Blurb, Report
import json
from .forms import JournalForm, AskJournalForm
import requests
# Create your views here.


# Simple helper function:
mood_colors = {
    "happy": "badge-primary",
    "sad": "badge-secondary",
    "angry": "badge-danger",
    "afraid": "badge-warning",
    "excited": "badge-success",
    "calm": "badge-info",
    "worried": "badge-light",
    "in love": "badge-danger",
    "surprised": "badge-warning",
    "proud": "badge-success",
    "ashamed": "badge-secondary",
    "frustrated": "badge-danger",
    "guilty": "badge-danger",
    "curious": "badge-info",
    "nostalgic": "badge-light",
    "hopeful": "badge-primary",
    "disappointed": "badge-secondary",
    "embarrassed": "badge-secondary",
    "envious": "badge-danger",
    "grateful": "badge-success",
    "longing": "badge-info",
    "relieved": "badge-primary",
    "optimistic": "badge-primary",
    "pessimistic": "badge-dark"
}

def mood_list_creation(entry: JournalEntry):
    return_list = []
    if(entry.mood is None):
        return ['<span class="badge badge-pill badge-light">Journal is yet to be processed by AI</span>']
    else:
        # We expect that entry.mood is a valid python array
        try:
            # Hacky way of doing this, but, this is the best I can think of
            print(json.loads(entry.mood.replace("'", '"'))) # AI will generate the list with either ' or ", this fixes it
            moodl = json.loads(entry.mood.replace("'", '"'))
            for element in moodl:
                print(element)
                if mood_colors.get(element) is not None:
                    return_list.append(f'<span class="badge badge-pill {mood_colors.get(element)}">{element}</span>')
        except:
           return ['<span class="badge badge-pill badge-danger">Mood list generated by AI is invalid</span>']
    print(return_list)
    return return_list

def journals(request):
    journal_entries = JournalEntry.objects.filter(user=request.user).order_by('-created_at')
    return render(request, 'journalindex.html', {'journal_entries': journal_entries}) #HttpResponse("Hello world!")

def journal_question(request):
    if request.method == "POST":
        form = AskJournalForm(request.POST, user=request.user)
        # This is a neat little trick, if we call it this way, it'll create it in memory but not persist to the database
        if form.is_valid():
            # Now, this is the step where we collate the question, journals, send to the AI, and display the response
            # Step 1: Collate the question and journals.
            prompt=f"You are an unbiased AI agent who has been given the task of answering a query from a user. The qeury from the user will require you to consider one or more journal entries, some of which will be relevant (important! not all journal entries may be relevant.) Your task is to answer the question of the user as best as you can while considering these journals. Where plausible, cite the journals in your answer if they are relevant.\n Format your response in markdown."
            question=f"\nNow, consider the question from the user:\n```{form.cleaned_data['question']}```\n"
            journal_preamble=f"Now, consider the following journal entries.\n"
            for journal in form.cleaned_data['journals']:
                journal_preamble+=f"Journal Entry:\nDate: {journal.date}\nContent:\n```{journal.content}```"
            print(prompt+question+journal_preamble)
            response = requests.post('http://ollama-intel-gpu:11434/api/generate', json={'model':'deepseek-r1:14b','stream':False,'prompt':prompt+question+journal_preamble})
            return render(request, 'report_detail.html', {'report_entry' : Report(user=request.user, title='Temporary Question', type='w', content=response.json()['response'].split('</think>')[1].strip()) })
        # This isn't nice, but, I see no better option. TODO to add some more verbose error reporting.
        return HttpResponseRedirect("/journals/")    
    else:
        form = AskJournalForm(user=request.user)
        return render(request, 'journal_ask.html', {'form': form})

def journal_detail(request, id):
    entry = get_object_or_404(JournalEntry, id=id, user=request.user)
    mood = mood_list_creation(entry)
    return render(request, 'journal_detail.html', {'entry': entry, 'moods' : mood})

def journal_create(request):
    if request.method == "POST":
        # create a form instance and populate it with data from the request:
        form = JournalForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            # process the data in form.cleaned_data as required
            print(form.cleaned_data)
            new = JournalEntry()
            print(form.errors)
            new.content = form.cleaned_data['content']
            if len(form.cleaned_data['reflections']) > 5:
                new.reflections = form.cleaned_data['reflections']
            if len(form.cleaned_data['gratitude']) > 5:
                new.gratitude = form.cleaned_data['gratitude']
            new.user =  request.user # This WILL error when not logged in, but, that's fine
            new.save()
            # Let's mark the blurbs as spent now
            # Note this has a known issue - if the blurb was sent after the user started journaling
            # but before it was submitted, it would be marked as spent. This is not a big deal.
            for blurb in Blurb.objects.filter(user=request.user, journalEntry=None):
                blurb.journalEntry = new
                blurb.save()
            # redirect to a new URL:
            return HttpResponseRedirect("/journals/")    
        return render(request, 'journal_submit.html', {'form':form})
    else:
        form = JournalForm()
        blurbs = list(Blurb.objects.filter(user=request.user, journalEntry=None))
        return render(request, 'journal_submit.html', {'form':form, 'blurbs' : blurbs})

def report_detail(request, id):
    report_entry = get_object_or_404(Report, id=id, user=request.user)
    return render(request, 'report_detail.html', {'report_entry' : report_entry})
